"
I am the abstract node of the block objects generated by `MicroDownParser`.

The root of the parsetree is an instance of `MicRootBlock`.
I have a set of children, and an uplink to my parent.

See the comment of `MicroDownParser` for an overview of the algorithm used in building such parse tree.
"
Class {
	#name : #MicAbstractBlock,
	#superclass : #MicElement,
	#instVars : [
		'parent',
		'children',
		'parser',
		'properties'
	],
	#category : #'Microdown-Model'
}

{ #category : #adding }
MicAbstractBlock >> addChild: childBlock [
	children add: childBlock
]

{ #category : #public }
MicAbstractBlock >> addLineAndReturnNextNode: line [
	"add line to this node. 
	Notice, the action is allowed to create new nodes in the block tree.
	Returns the node to handle next line - typically self."

	self subclassResponsibility.
	^ self
]

{ #category : #public }
MicAbstractBlock >> blockExtensionStarterClassFrom: line [
	"return the class of a block which can start with line, or nil if none"

	^ nil
]

{ #category : #public }
MicAbstractBlock >> blockStarterClassFrom: line [
	"return the class of a block which can start with line, or nil if none"

	^ self parser blockStarterClassFrom: line
]

{ #category : #public }
MicAbstractBlock >> canConsumeLine: line [
	"return if this block can consume line"

	^ self subclassResponsibility 
]

{ #category : #adding }
MicAbstractBlock >> children [
	^children 
]

{ #category : #adding }
MicAbstractBlock >> children: aCollection [
 	children := aCollection
]

{ #category : #public }
MicAbstractBlock >> closeMe [
	"I'm hook for closing elements. By default do nothing."
	
	^ self
]

{ #category : #public }
MicAbstractBlock >> computeNestedLevel [ 

	^ 0
]

{ #category : #properties }
MicAbstractBlock >> hasProperty: aKey [
	"Test if the property aKey is present."
	
	^ self properties notNil and: [ self properties includesKey: aKey ]
]

{ #category : #accessing }
MicAbstractBlock >> indent [
	^ parent indent
]

{ #category : #initialization }
MicAbstractBlock >> initialize [
	super initialize. 
	children := OrderedCollection new.
]

{ #category : #testing }
MicAbstractBlock >> listItemBlockClass [
	^ MicListItemBlock
]

{ #category : #public }
MicAbstractBlock >> nestedLevel [ 
	"Return the nesting level of main blocks. Basically only list increases this."
	
	^ 0
]

{ #category : #public }
MicAbstractBlock >> newBlockFor: line parent: parentBlock [
	| newBlockClass |
	newBlockClass := self blockStarterClassFrom: line.
	newBlockClass ifNil: [ ^parentBlock ].
	^ newBlockClass new
		setParser: parser;
		parent: parentBlock;
		addLineAndReturnNextNode: line
]

{ #category : #accessing }
MicAbstractBlock >> parent [
	^ parent
]

{ #category : #accessing }
MicAbstractBlock >> parent: aBlock [
	parent := aBlock.
	aBlock addChild: self
]

{ #category : #private }
MicAbstractBlock >> parser [
	^ parser 
]

{ #category : #private }
MicAbstractBlock >> parserClass [ 
	^ MicroDownParser 
]

{ #category : #properties }
MicAbstractBlock >> properties [
	^ properties ifNil: [ properties := Dictionary new ]
]

{ #category : #properties }
MicAbstractBlock >> propertiesCopy [
	self properties ifNil: [ ^ nil ].
	^ self properties collect: [ :each | each copy ]
]

{ #category : #properties }
MicAbstractBlock >> propertyAt: aKey [
	"Answer the property value associated with aKey."
	
	^ self propertyAt: aKey ifAbsent: [ MicPropertyError signal: 'Property not found' ]
]

{ #category : #properties }
MicAbstractBlock >> propertyAt: aKey ifAbsent: aBlock [
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."
	
	^ self properties isNil
		ifTrue: [ aBlock value ]
		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]
]

{ #category : #properties }
MicAbstractBlock >> propertyAt: aKey ifAbsentPut: aBlock [
	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."
	
	^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]
]

{ #category : #properties }
MicAbstractBlock >> propertyAt: aKey put: anObject [
	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."

	^ (properties ifNil: [ properties := (IdentityDictionary new: 1) ])
		at: aKey put: anObject
]

{ #category : #properties }
MicAbstractBlock >> removeProperty: aKey [
	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."
	
	^ self removeProperty: aKey ifAbsent: [ MicPropertyError signal: 'Property not found' ]
]

{ #category : #properties }
MicAbstractBlock >> removeProperty: aKey ifAbsent: aBlock [
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| answer |
	self properties ifNil: [ ^ aBlock value ].
	answer := self properties removeKey: aKey ifAbsent: aBlock.
	self properties isEmpty ifTrue: [ properties := nil ].
	^ answer
]

{ #category : #private }
MicAbstractBlock >> setParser: aParser [
	parser := aParser 
]
